package utils;

import common.JplRule;
import common.Predicate;
import common.PredicateCreationException;
import common.Rule;
import org.jpl7.Atom;
import org.jpl7.Compound;
import org.jpl7.Term;
import org.jpl7.Variable;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Read stringfied rules generated by amie and construct as 'Rule' objects
 */
public class AmieRuleLoader {
    public static Rule loadRule(String rule, Map<String, Integer> predicateMap, Map<String, Integer> constantMap)
            throws PredicateCreationException {
        Map<String, Integer> variable_id_map = new HashMap<>();
        String[] components = rule.split("\\s+");
        List<Predicate> body = new ArrayList<>();
        int idx = 0;
        boolean is_in_body = true;
        while (true) {
            /* Continuously convert body predicates */
            String subj = components[idx];
            String pred = components[idx+1];
            String obj = components[idx+2];

            int[] paras = new int[2];
            boolean[] is_variable = new boolean[2];
            if (subj.charAt(0) == '?') {
                paras[0] = variable_id_map.computeIfAbsent(subj, k -> variable_id_map.size());
                is_variable[0] = true;
            } else {
                paras[0] = constantMap.get(subj);
            }
            if (obj.charAt(0) == '?') {
                paras[1] = variable_id_map.computeIfAbsent(obj, k -> variable_id_map.size());
                is_variable[1] = true;
            } else {
                paras[1] = constantMap.get(obj);
            }

            Predicate predicate = new Predicate(0, predicateMap.get(pred), paras, is_variable);
            if (is_in_body) {
                body.add(predicate);
            } else {
                return new Rule(predicate, body);
            }

            idx += 3;
            if (components[idx].charAt(0) == '=') {
                /* Convert head predicate and break */
                is_in_body = false;
                idx++;
            }
        }
    }

    public static Rule[] loadRules(String[] rules, Map<String, Integer> predicateMap, Map<String, Integer> constantMap) {
        List<Rule> result = new ArrayList<>();
        for (String rule: rules) {
            try {
                result.add(loadRule(rule, predicateMap, constantMap));
            } catch (PredicateCreationException e) {
                e.printStackTrace();
            }
        }
        return result.toArray(new Rule[0]);
    }

    public static String toPrologSyntaxString(String rule) {
        Map<String, Integer> variable_id_map = new HashMap<>();
        String[] components = rule.split("\\s+");
        int idx = 0;
        boolean is_in_body = true;
        List<String> body_preds = new ArrayList<>();
        while (true) {
            /* Continuously convert body predicates */
            String subj = components[idx];
            String pred = components[idx+1];
            String obj = components[idx+2];

            StringBuilder pred_str_builder = new StringBuilder(pred);
            pred_str_builder.append('(');
            if (subj.charAt(0) == '?') {
                pred_str_builder.append('X').append(variable_id_map.computeIfAbsent(subj, k -> variable_id_map.size()));
            } else {
                pred_str_builder.append(subj);
            }
            pred_str_builder.append(',');
            if (obj.charAt(0) == '?') {
                pred_str_builder.append('X').append(variable_id_map.computeIfAbsent(obj, k -> variable_id_map.size()));
            } else {
                pred_str_builder.append(obj);
            }
            pred_str_builder.append(')');

            if (is_in_body) {
                body_preds.add(pred_str_builder.toString());
            } else {
                StringBuilder rule_builder = pred_str_builder;
                rule_builder.append(":-");
                if (0 < body_preds.size()) {
                    rule_builder.append(body_preds.get(0));
                    for (int i = 1; i < body_preds.size(); i++) {
                        rule_builder.append(',').append(body_preds.get(i));
                    }
                }
                return rule_builder.toString();
            }

            idx += 3;
            if (components[idx].charAt(0) == '=') {
                /* Convert head predicate and break */
                is_in_body = false;
                idx++;
            }
        }
    }

    public static JplRule toPrologSyntaxObject(String rule) {
        Map<String, Integer> variable_id_map = new HashMap<>();
        String[] components = rule.split("\\s+");
        int idx = 0;
        boolean is_in_body = true;
        List<Compound> body_preds = new ArrayList<>();
        while (true) {
            /* Continuously convert body predicates */
            String subj = components[idx];
            String pred = components[idx+1];
            String obj = components[idx+2];

            Term subj_term, obj_term;
            if (subj.charAt(0) == '?') {
                subj_term = new Variable(String.format(
                        "X%d", variable_id_map.computeIfAbsent(subj, k -> variable_id_map.size()))
                );
            } else {
                subj_term = new Atom(subj);
            }
            if (obj.charAt(0) == '?') {
                obj_term = new Variable(String.format(
                        "X%d", variable_id_map.computeIfAbsent(obj, k -> variable_id_map.size()))
                );
            } else {
                obj_term = new Atom(obj);
            }

            if (is_in_body) {
                body_preds.add(new Compound(pred, new Term[]{subj_term, obj_term}));
            } else {
                return new JplRule(
                        new Compound(pred, new Term[]{subj_term, obj_term}), body_preds.toArray(new Compound[0])
                );
            }

            idx += 3;
            if (components[idx].charAt(0) == '=') {
                /* Convert head predicate and break */
                is_in_body = false;
                idx++;
            }
        }
    }
}
